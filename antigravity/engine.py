import asyncio
from typing import Dict, List
from antigravity.logging import get_logger
from antigravity.event import event_bus, MarketDataEvent, KlineEvent, on_event, SentimentEvent
from antigravity.strategy import AbstractStrategy, Signal
from antigravity.risk import RiskManager
from antigravity.database import db
from antigravity.execution import execution_manager
from antigravity.ml_engine import ml_engine

logger = get_logger("strategy_engine")

class StrategyEngine:
    def __init__(self):
        self.strategies: Dict[str, AbstractStrategy] = {}
        self._running = False
        self.risk_manager = RiskManager()
        self.ml_engine = ml_engine

    def register_strategy(self, strategy: AbstractStrategy):
        self.strategies[strategy.name] = strategy
        logger.info("strategy_registered", name=strategy.name, symbols=strategy.symbols)

    async def start(self):
        self._running = True
        logger.info("strategy_engine_started")
        if self.ml_engine.enabled:
             logger.info("ml_engine_active")
        
        # Subscribe to Events
        event_bus.subscribe(MarketDataEvent, self._handle_market_data)
        event_bus.subscribe(KlineEvent, self._handle_market_data)
        event_bus.subscribe(SentimentEvent, self._handle_sentiment)

    async def stop(self):
        self._running = False
        logger.info("strategy_engine_stopped")

    async def _handle_market_data(self, event: MarketDataEvent):
        if not self._running:
            return

        # Persist Klines
        if isinstance(event, KlineEvent):
            db.save_kline(event.symbol, event.interval, event.open, event.high, event.low, event.close, event.volume, event.timestamp)
            
            # Future: ML Prediction Hook here
            # prediction = await self.ml_engine.predict_price_movement(event.symbol, {"close": event.close})

        # Forward to all strategies
        for name, strategy in self.strategies.items():
            if not strategy.is_active:
                continue
                
            try:
                signal = await strategy.on_market_data(event)
                if signal:
                    await self._handle_signal(signal, strategy.name)
            except Exception as e:
                logger.error("strategy_error", strategy=name, error=str(e))

    async def _handle_sentiment(self, event: SentimentEvent):
        db.save_sentiment("BTCUSDT", event.score, event.reasoning, event.model)

    async def _handle_signal(self, signal: Signal, strategy_name: str):
        """
        Process a signal generated by a strategy. 
        """
        # 1. Risk Check
        if not self.risk_manager.check_signal(signal):
            logger.info("signal_rejected_by_risk", strategy=strategy_name, symbol=signal.symbol)
            return

        logger.info("signal_accepted", 
                    strategy=strategy_name, 
                    type=signal.type.value, 
                    symbol=signal.symbol, 
                    price=signal.price)
        
        # 2. Persist Signal
        db.save_signal(strategy_name, signal.symbol, signal.type.value, signal.price, signal.reason)

        # 3. Execute Signal
        await execution_manager.execute(signal, strategy_name)

# Global Engine Instance
strategy_engine = StrategyEngine()
